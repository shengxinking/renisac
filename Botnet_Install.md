# Introduction #

This section details the steps required to successfully install and test the botnet plugin for NFSen. The Botnet plugin heavily depends on the NFSen Events plugin. The Events plugin is responsible for processing and storing alerts generated by the Botnet plugin. This guide will first detail the process for installing Events and subsequently the Botnet Plugin.

# Install Events-Plugin #

**Step 1:** Download the NFSen Events plugin

> ```
$ cd /tmp
$ wget http://downloads.sourceforge.net/project/nfsen-plugins/events/0.3/nfsen-events-0.3.tar.gz```
> ```
$ sudo tar -zxvf nfsen-events-0.3.tar.gz
$ cd nfsen-events-0.3```

You can change the location of the uncompressed files to a location of your liking or leave it in the /tmp directory.

**Step 2:** Install prerequisite packages for Events plugin

> ```
$ sudo apt-get install mysql-server php5-mysql libmysqlclient-dev```

_If using an existing MySQL server, only **php5-mysql** and **libmysqlclient-dev** are required on the NFSen box._

**Step 3:** Install prerequisite perl modules

> ```
$ sudo perl -MCPAN -e 'install PHP::Serialization'```
> ```
$ sudo perl -MCPAN -e 'install DBI'```
> ```
$ sudo perl -MCPAN -e 'install DBD::mysql'```

**Step 4:** Copy backend and frontend plugin files to $BACKEND\_PLUGINDIR and $FRONTEND\_PLUGINDIR locations specified in /etc/nfsen.conf

> ```
 # Copy contents from backend directory to /usr/local/nfsen/plugins/
$ sudo cp backend/Events.pm /usr/local/nfsen/plugins/```

> ```
 # Copy contents from frontend directory to /var/www/nfsen/plugins/
$ sudo cp frontend/Events.php /var/www/nfsen/plugins/```

**Step 5:** Setup and configure the MySQL database required by the Events plugin

First set a password for the root mysql account:

> ```
$ mysqladmin –u root password <enter desired root password here>```

Once set login to mysql as root and create a user account for the Events plugin.

> ```
$ mysql -u root -p<password-string>
mysql> CREATE USER ‘<user>’@’localhost’ INDENTIFIED BY ‘<password-string>’;```
> ```
mysql> quit```

The following SQL script can be used to assign user privileges and create the required database/tables. The final statement executes another SQL script which creates the tables. The _mysql\_tables.txt_ file is packaged with the Events plugin and is located in the source directory.

> ```
CREATE DATABASE events;
GRANT SELECT, INSERT, DELETE, UPDATE ON events.* TO '<user>'@'localhost' IDENTIFIED BY '<password-string>';
USE events;
SOURCE mysql_tables.txt;```

Place the script in a text file. **Make sure the script is saved in the same directory as mysql\_tables.txt at /tmp/nfsen-events-0.3/.** Execute the above script from the /tmp/nfsen-events-0.3/ directory using the following command:

> ```
$ sudo mysql -u root -p<password-string> < <Path-to-SQL-Script>```

Or from the MySQL CLI as root user

> ```
mysql> SOURCE <name-of-script>.sql```

Next verify if the database/table creation was successful through the MySQL CLI

> ```
mysql> USE events;```

Expected Output:

> ```
mysql> SHOW COLUMNS FROM attributes;
+--------------+------------------+------+-----+---------+----------------+
| Field        | Type             | Null | Key | Default | Extra          |
+--------------+------------------+------+-----+---------+----------------+
| attribute_id | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| event_id     | int(10) unsigned | YES  | MUL | NULL    |                |
| name         | varchar(32)      | YES  |     | NULL    |                |
| value        | varchar(64)      | YES  |     | NULL    |                |
+--------------+------------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)```

> ```
mysql> SHOW COLUMNS FROM events;
+------------+------------------+------+-----+---------+----------------+
| Field      | Type             | Null | Key | Default | Extra          |
+------------+------------------+------+-----+---------+----------------+
| event_id   | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
| starttime  | int(10)          | NO   |     | NULL    |                |
| stoptime   | int(10)          | YES  | MUL | NULL    |                |
| updatetime | int(10)          | NO   |     | NULL    |                |
| level      | varchar(32)      | NO   |     | NULL    |                |
| profile    | varchar(100)     | NO   |     | NULL    |                |
| type       | varchar(32)      | NO   |     | NULL    |                |
+------------+------------------+------+-----+---------+----------------+
7 rows in set (0.00 sec)```

**Step 6:** Configure the Events plugin in nfsen.conf

The nfsen.conf file is located according to the value of the $CONFDIR parameter during the NFSen installation process. We changed the default value to $CONFDIR="/etc". Therefore, we will be making changes to the /etc/nfsen.conf configuration file.

In order to get the plugin to be recognized by NFSen, a definition must be added to the **@plugins** list of the nfsen.conf configuration file. Additionally, any required plugin configuration must be added to the **%PluginConf** section of nfsen.conf.

First, open the nfsen configuration file with a text editor.

> ```
$ sudo vi /etc/nfsen.conf```

At line 213, add the following to the **@plugins** list:

> ```
    [ "live", 'Events' ],```

At line 220, add the following to the **%PluginConf** section:

> ```
        events => {
db_connection_string    => "DBI:mysql:database=events;host=localhost;port=3306",
db_user                 => "<mysql-user>",
db_passwd               => "<password-string>",
},```

This creates the database connection to MySQL for the Events plugin. If the mysql server is installed and configured on the same machine then the **host** option must be set to localhost. Otherwise, set the value equal to the IP or FQDN of the remote SQL server.

**Step 7:** Reload the NFSen configuration file

> ```
$ sudo service nfsen reload```

**Step 8:** Verify a successful install

Check the syslog messages in /var/log/nfsen/nfsen.log. If the plugin loaded and initialized successfully you should see logs resembling the following.

> ```
Jul  7 18:29:23 ubuntu nfsen[3924]: Loading plugin 'Events': Success
Jul  7 18:29:23 ubuntu nfsen[3924]: Initializing plugin 'Events': Success```

The log file is invaluable for troubleshooting problems with NFSen. If a failed status is returned, search the logs for additional information. For instance, the plugin may not have been able to establish a connection to the database. The logs will also indicate whether a required dependency is missing as well. All of this information is available through examining the NFSen syslog messages.

An additional tab should now also be available through the Plugins tab of the NFSen web Front-End. Example output is illustrated below.

![http://www.ren-isac.net/img/googlecode/7.2.1.1-Events_Plugin.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.1-Events_Plugin.jpg)

# Please Read First Before Proceeding #

The botnet plugin requires a list of botnet-c&c's in order to work. The plugin uses the information contained in the list to create NFSen filters for identifying suspected botnet c&c communication in the stored NetFlow data. One publicly available list can be found at:

http://rules.emergingthreats.net/blockrules/emerging-botcc.rules

The botnet plugin expects a pipe delimited list in the following format:

  * ip-adress
  * port-number
  * and a protocol number
  * name of the source of the list
  * timestamp of the list
  * time-out of the botnet-c&c (when does it become invalid)
  * botnet identification

Expected Format:
> ```
IP_Address|Port-Number|Protocol-Number|Source-of-List|UNIX-Timestamp-of-List|UNIX-Timeout-of-List|Botnet-ID```

_Botnet-ID is stored in a varchar(64) field in the MySQL database. The value can be text or an integer._

The NFSen Botnet plugin comes packaged with a perl script that parses the c&c list and outputs a pipe delimited list in the format indicated above. However, as previously indicated, the provided perl script is written to parse a dataset in the snort filter syntax. Therefore, one must write script to import datasets which do not conform to the snort syntax.

**However, as long as the source information is formatted to a pipe delimited list as specified above, the dataset can come from any source.** An example list is illustrated below.

Example List:

> ```

103.13.240.2|||emergingthreads|1372997413|1373602213|
103.6.207.37|||emergingthreads|1372997413|1373602213|
106.187.42.91|||emergingthreads|1372997413|1373602213|```

# Install Botnet-Plugin #

**Step 1:** Download the NFSen Events plugin

> ```
$ cd /tmp
wget http://downloads.sourceforge.net/project/nfsen-plugins/botnet/0.3/nfsen-botnet-0.3.tar.gz```
> ```
$ sudo tar -zxvf nfsen-botnet-0.3.tar.gz
$ cd nfsen-botnet-0.3```

**Step 2:** Copy backend plugin and botnet-filter bin files to $BACKEND\_PLUGINDIR and $BIN\_DIR locations specified in /etc/nfsen.conf

> ```
 # Copy contents from backend directory to /usr/local/nfsen/plugins/
$ sudo cp backend/Botnets.pm /usr/local/nfsen/plugins/```

> ```
 # Copy botnet-filter from bin directory to /usr/local/nfsen/bin
$ sudo cp bin/botnet_filter /usr/local/nfsen/bin```

**Step 3:** Create a directory to store the pipe delimited list to be used by the plugin (list of known botnet c&c's).

> ```
$ sudo mkdir /var/botlist```

As a reminder, the list must be in the following format:

Expected Format:
> ```
IP_Address|Port-Number|Protocol-Number|Source-of-List|UNIX-Timestamp-of-List|UNIX-Timeout-of-List|Botnet-ID```

**Step 4:** Configure the Botnet plugin in nfsen.conf

In order to get the plugin to be recognized by NFSen, a definition must be added to the **@plugins** list of the nfsen.conf configuration file. Additionally, any required plugin configuration must be added to the **%PluginConf** section of nfsen.conf.

First, open the nfsen configuration file with a text editor.

> ```
$ sudo vi /etc/nfsen.conf```

At line 213, add the following to the **@plugins** list:

> ```
    [ "!", 'Botnets' ],```

At line 220, add the following to the **%PluginConf** section:

> ```
        botnets => {
import_cmd             => "cat /var/botlist/botlist.txt",
match_proto            => "0",
match_port             => "0",
},```

Please note **match\_proto=>0** and **match\_proto=>0** are optional parameters. **When set to 0, these fields are not included during processing of the botnet list. If your intent is to match protocol and port number in addition to IP address, then these fields should not be omitted and set to the desired value.**

**Step 5:** Reload the NFSen configuration file

> ```
$ sudo service nfsen reload```

**Step 6:** Verify a successful install

Check the syslog messages in /var/log/nfsen/nfsen.log. If the plugin loaded and initialized successfully you should see logs resembling the following.

> ```
Jul  7 18:29:23 ubuntu nfsen[3924]: Loading plugin 'Botnets': Success
Jul  7 18:29:23 ubuntu nfsen[3924]: Initializing plugin 'Botnets': Success```

If a failed status is returned, search the logs for additional information.

**Step 7:** Setup the botnet plugin in the NFSen web GUI

Open a web browser and navigate to the Main NFSen page via http://localhost/nfsen/nfsen.php or http://<ip-address/nfsen/nfsen.php. Once loaded, click the alerts tab at the top right of the "Alerts Overview:" pane and click on the + sign to add a new alert.

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Blank-Alert-Page_new.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Blank-Alert-Page_new.jpg)

Give the alert a name of "botlist" and check the box for enabled. This will ensure the alert will go live upon creation. Select the NetFlow sources to filter for botnet c&c communication (a single alert can be applied to as many NetFlow sources as defined in the NFSen profile). Leave the filter box empty.

When left blank an automatic filter of 'not any' is assumed. This is fine since in a subsequent step we will import the Emerging Threats dataset for filtering botnet c&c communication. Select the alert "Conditions based on plugin:" and select the "Botnets" plugin. Finally, click the "Create Alert" button to create and deploy the alert.

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-2.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-2.jpg)

After successful creation you will be returned to the details page of the newly created alert. As shown in the graphic, the default 'not any' filter has been applied to the alert.

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-New-Alert2.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-New-Alert2.jpg)

The Alert Infos panel draws a graphical distribution of the average amount of botnet c&c over different periods of time. A table also provides this same information separated by number of flows, packets, and bit rate. Finally, the conditions table keeps track of the number of conditions met by the botnet plugin and whether a condition is in the True or False state.

Once a condition has reached a status of True and True, the alert is triggered and the botnet plugin sends the alert to the events plugin for processing and storage.

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Alert-Graph.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Alert-Graph.jpg)

The Alert details page for the created alert can be revisited by clicking the "view alert" button under "Alerts Overview:"

![http://www.ren-isac.net/img/googlecode/7.2.1.3-New-Alert-Page.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-New-Alert-Page.jpg)

**Step 8: Import a dataset to be used by the botnet plugin**

If you already have a pipe delimited list to be used by the plugin, then store the list in /var/botlist as **botlist.txt**. The [next section](https://code.google.com/p/renisac/wiki/Botnet_Install#Importing_Datasets) covers integrating different datasets into the plugin. **To import the list execute the following command:**

> ```
$ sudo bash
$ botnet_filter < /var/botlist/botlist.txt > /usr/local/nfsen/profiles-stat/~botlist/botlist-filter.txt```

To verify whether the dataset was successfully imported, navigate back to the "Alert Details:" panel for the "botlist" alert. If the process was successful, a large list of IP's will be present in the filter box wrapped in the NFSen filter syntax.

An example of expected output:

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-1v3.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-1v3.jpg)


## Importing Datasets ##

This section provides examples of integrating different datasets for use by the botnet plugin. One or many datasets can be imported into the plugin. As previously mentioned, the plugin expects a pipe delimited list in the format:

> ```
IP_Address|Port-Number|Protocol-Number|Source-of-List|UNIX-Timestamp-of-List|UNIX-Timeout-of-List|Botnet-ID```

As long as the dataset being imported conforms to this format, then the data can come from any source. Since the plugin expects a single pipe delimited list, in order to aggregate multiple sources of known botnet c&c lists, all one must do is append the new data to the end of the file. The plugin configuration in nfsen.conf includes a parameter **import\_cmd** contains the command that needs to be executed to generate the pipe delimited list. This list is fed into /usr/local/nfsen/bin/botnet\_filter. **botnet\_filter** is a perl script which parses the provided pipe delimited list and outputs an NFSen filter. The resulting output is an NFSen filter to be used by the plugin. As you will see in the Emerging Threats example, the resulting NFSen filter is stored in /usr/local/nfsen/profiles-stat/(alert\_name), which is the default location where NFSen looks for the alert filter.

Port and Protocol can also be used as a basis for filtering in addition to IP Address. To accomplish this, the **match\_proto** and **match\_port** fields must be set to a value in the plugin configuration of nfsen.conf. Additionally, the **port-number** and **port-protocol** must be included in the pipe delimited list expected by botnet-filter.

### The Emerging Threats Example ###

As mentioned previously, the botnet plugin comes packaged with a perl script to import a c&c list from Emerging Threats. These scripts can be found in the _emergingthreads\_example_ directory in the source directory for the botnet plugin (nfsen-botnet-0.3). The provided perl and shell scripts can be adapted to import a dataset from any source. **The Emerging Threats-c&c list is written in the snort drop filter syntax.** Therefore, the script must be adapted to conform to the syntax of other datasets. **Straight out of the box the scripts require some modification in order to work. To get started, we recommend using our modified version.** The resulting output will be a pipe delimited list containing the IP, Name of source, Timestamp, and Timeout values (when the list expires). Additionally, botnet.cron invokes botnet-filter which is fed the pipe delimited list and outputs an NFSen filter to be used by the botnet plugin.

Expected Format for botnet-filter:
> ```
IP_Address|Port-Number|Protocol-Number|Source-of-List|UNIX-Timestamp-of-List|UNIX-Timeout-of-List|Botnet-ID```

_Botnet-ID is stored in a varchar(64) field in the MySQL database. The value can be text or an integer._

**Step 1:** Save these scripts to to the /usr/local/nfsen/bin directory. Our version of the scripts can be found below:

**botnet.cron**

> ```
#!/bin/sh
printf "Changing directory to $1\n"
cd $1
printf "Current directory is $1\n"
printf "Downloading emerging-botcc.rules\n"
wget http://rules.emergingthreats.net/blockrules/emerging-botcc.rules
printf "Downloaded emerging-botcc.rules to $1$(ls | grep emerging-botcc.rules)\n\n"
printf "Executing /usr/local/bin/get_botnets_emerging-botcc\n"
printf "Converting emerging-botcc.rules to a pipe delimited list\n"
get_botnets_emerging-botcc ./emerging-botcc.rules > $2
printf "List saved to $2\n\n"
printf "Creating botnet filter from $2\n"
botnet_filter < $2 > $3
printf "Botnet filter saved to $3\n\n"
printf "Removing emerging-botcc.rules from $1\n"
rm emerging-botcc.rules```

**get\_botnets\_emerging-botcc**

> ```
#!/usr/bin/perl
sub get_version ($) {
my ($filename) = @_;
return stat -t $filename | cut -f 13 -d" ";
}
$filename = $ARGV[0];
my ($stamp) = get_version($filename);
chomp($stamp);
# c&c's are timed out one week after the lists age. This means that we don't accept c&c's from a list that is older than a week
my $expire = $stamp + 86400*7;
open(BOTNETS, "<$filename");
foreach my $line (<BOTNETS>) {
next if ($line =~ /\s*\#.*$/ || $line =~ /\s*$/); # skip empty and comment lines
my ($ip_list) = $line=~m/alert tcp \$HOME_NET any \-\> \[([^\]]+)\]/;
foreach my $ip (split(/,/,$ip_list)) {
print join('|',$ip, "", "", "emergingthreads", $stamp, $expire, "")."\n";
}
}```

Example Output of **get\_botnets\_emerging-botcc**:

> ```

103.13.240.2|||emergingthreads|1372997413|1373602213|
103.6.207.37|||emergingthreads|1372997413|1373602213|
106.187.42.91|||emergingthreads|1372997413|1373602213|```

The botnet plugin can filter c&c communication according to protocol and port number as well. In order to accomplish this, additional logic must be added to parse and output the protocol and port number fields in the pipe delimited format specified previously.

**Step 2:** Run **botnet.cron** for the first time to import the Emerging Threats dataset. The command syntax and a example are illustrated below

**Syntax:**

> ```
$ sudo botnet.cron <RAW_LIST_LOCATION> <LIST_LOCATION> <$PROFILESTATDIR>/~<ALERT_NAME>/<ALERT_NAME>```

**Arguments:**

  * RAW\_LIST\_LOCATION is the location where the script should put the original list
  * LIST\_LOCATION is the location where the script should put the converted list
  * $PROFILESTATDIR is the value of $PROFILESTATDIR in your nfsen.conf
  * ALERT\_NAME is the name you have choosen for the alert

**Example:**

> ```
$ sudo botnet.cron /tmp/ /var/botlist/botlist.txt /usr/local/nfsen/profiles-stat/~botlist/botlist-filter.txt```

In order to keep the list up to date, it's generally a good idea to update the list no later than a week. Later in this section, we provide an example crontab job to automate this process.

**botnet.cron performs the following operations:**

  * Downloads a public botnet-c&c list to the /tmp/ directory
  * Exectutes the /usr/local/nfsen/bin/get\_botnets\_emerging-botcc perl script passing the raw list as an argument. get\_botnets\_emerging-botcc outputs a pipe delimited list in the format:

> ```
IP_Address|Port-Number|Protocol-Number|Source-of-List|UNIX-Timestamp-of-List|UNIX-Timeout-of-List|Botnet-ID```

  * The new list is then passed to /usr/local/nfsen/bin/botnet-filter which generates an NFSen filter for the botnet plugin.

**Step 3:** Install crontab job to automatically renew the list before the expiration timestamp

As mentioned previously, the botnet list should updated no later than a week. Below is an example crontab job to automate this process.

> ```
PROFILESTATDIR=/usr/local/nfsen/profiles-stat
RAW_LIST_LOCATION=/tmp/
LIST_LOCATION=/var/botlist/botlist.txt
ALERT_NAME="botlist"
0 * * * * botnet.cron $RAW_LIST_LOCATION $LIST_LOCATION $PROFILESTATDIR/~$ALERT_NAME/$ALERT_NAME-filter.txt```

**Step 4:** Verify the dataset was successfully imported into the plugin

To verify whether the dataset was successfully imported, navigate back to the "Alert Details:" panel for the "botlist" alert. If the process was successful, a large list of IP's will be present in the filter box wrapped in the NFSen filter syntax.

An example of expected output:

![http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-1v3.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3-Botnet-Setup-1v3.jpg)

### Integrating Data from CIF ###

This section is left open for future work.

## Testing the Botnet Plugin ##

The botnet plugin simply filters for communication to any of the imported IP addresses (the plugin could additionally consider port and protocol by modifying math\_proto and match\_port parameters of the plugin in @plugins section of nfsen.conf) in the gathered NetFlow data. The ping utility can be used to test the plugin. Use ping to continuously ping one of the addresses in the c&c list. **Note!** If matching on protocol and port, you may have to use a tool to generate custom UDP/TCP traffic based on the what the plugin expects according to these parameters. **The imported dataset in the previous section must also include the port and protocol information.** A couple of examples of tools to create custom packets are tools like **hping3** or **scapy**. One communication with a known c&c has begun, you will start to see data being plotted to the RRD graph as illustrated below.

![http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Botnet-Detected.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Botnet-Detected.jpg)

Having traffic show up on the graphs does not necessarily mean  the presence of a botnet. You may also notice that data is being gathered but the alert is still in the Alarm state. This is because the conditions of the alert are based on the Botnet plugin. By default, just by issuing ICMP traffic at a normal rate, we observed the alert typically triggers around the 30-40 minute mark (this is assuming the trigger configuration was left to its defaults when creating the alert). So go grab a coffee, or read a book, the alert may take awhile to trigger. Modifying the interval of ICMP traffic to the target host can decrease this time.

![http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Alert-Fired.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Alert-Fired.jpg)

The alert performs a checkpoint at a pre-determined time interval and evaluates whether an alert condition is true. One can verify the result of each check by parsing through the /var/log/nfsen/nfsen.log file.

> ```
$ grep botlist /var/log/nfsen/nfsen.log | less```

Example Output:

> ```

Jul  9 01:45:16 ubuntu nfsen[3436]: Process alert 'botlist'
Jul  9 01:45:16 ubuntu nfsen[3436]: alert 'botlist': conditions based on plugin
Jul  9 01:45:16 ubuntu nfsen[4539]: Botnets: timeslot: 201307090140 alert: botlist alertfile: /var/log/netflowdata/~botlist/botlist/nfcapd.201307090140
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' condition == true, condition counter: 1
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' no action defined
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' Status: 5.
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' Blocks: 0.
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' Info  : .
Jul  9 01:45:16 ubuntu nfsen[3436]: Alert 'botlist' done.```

The output indicates the conditions of the 'botlist' alert, the time of the check, the NetFlow dump being checked, the result of the check (whether the check returned a true or false value), and any actions taken as a result.

Once the alert triggers, the event information is sent to the events plugin for storage in the MySQL database. Each time a checkpoint with a true condition is observed, the event information is updated. The **times** field specifies the number of checkpoints an event with a true condition has been observed. Each time a checkpoint returns true, the times field is incremented. The **updatetime** represents the timestamp of when the alert was triggered and the event was updated in the database. The **type** field indicates the type of event raised by the alert. The **attributes** column contains further information describing the event. The **actions** column indicates whether any action was taken in response to an event. In this case an action would represent whether an notification email was sent as defined in the Alert configuration.

![http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Botnet-Detected2.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.3.2-Botnet-Detected2.jpg)

Log in to mysql to verify the population of the events and attributes tables of the events database.

> ```
$ mysql -u <user> -p<password-string>
mysql> USE events;```

Output should resemble the following:

> ```
mysql> SELECT * FROM events;
+----------+------------+----------+------------+--------+---------+--------+
| event_id | starttime  | stoptime | updatetime | level  | profile | type   |
+----------+------------+----------+------------+--------+---------+--------+
|        1 | 1373556300 |     NULL | 1373647200 | notify | ./live  | botnet |
|        2 | 1373556300 |     NULL | 1373647200 | notify | ./live  | botnet |
|        3 | 1373556300 |     NULL | 1373647200 | notify | ./live  | botnet |
|        4 | 1373604000 |     NULL | 1373662800 | notify | ./live  | botnet |
|        5 | 1374033600 |     NULL | 1374033600 | notify | ./live  | botnet |
|        6 | 1374057600 |     NULL | 1374108000 | notify | ./live  | botnet |
+----------+------------+----------+------------+--------+---------+--------+
6 rows in set (0.00 sec)```


> ```

mysql> SELECT * FROM attributes;
+--------------+----------+-------------+-----------------+
| attribute_id | event_id | name        | value           |
+--------------+----------+-------------+-----------------+
|            1 |        1 | Times       | 2717            |
|            2 |        1 | Destination | 109.111.79.4    |
|            3 |        1 | Timestamp   | 1373515812      |
|            4 |        1 | Reporter    | emergingthreads |
|            5 |        1 | botnet_id   | 0               |
|            6 |        1 | Source      | 129.79.49.81    |
|            7 |        2 | Times       | 2728            |
|            8 |        2 | Destination | 108.61.26.189   |
|            9 |        2 | Timestamp   | 1373515812      |
|           10 |        2 | Reporter    | emergingthreads |
|           11 |        2 | botnet_id   | 0               |
|           12 |        2 | Source      | 129.79.49.82    |
|           13 |        3 | Times       | 2720            |
|           14 |        3 | Destination | 109.169.93.19   |
|           15 |        3 | Timestamp   | 1373515812      |
|           16 |        3 | Reporter    | emergingthreads |
|           17 |        3 | botnet_id   | 0               |
|           18 |        3 | Source      | 129.79.49.83    |
|           19 |        4 | Times       | 2               |
|           20 |        4 | Destination | 37.59.63.57     |
|           21 |        4 | Timestamp   | 1373515812      |
|           22 |        4 | Reporter    | emergingthreads |
|           23 |        4 | botnet_id   | 0               |
|           24 |        4 | Source      | 129.79.49.84    |
|           25 |        5 | Times       | 1               |
|           26 |        5 | Destination | 37.59.63.57     |
|           27 |        5 | Timestamp   | 1373515812      |
|           28 |        5 | Reporter    | emergingthreads |
|           29 |        5 | botnet_id   | 0               |
|           30 |        5 | Source      | 129.79.49.83    |
|           31 |        6 | Times       | 2               |
|           32 |        6 | Destination | 37.59.63.57     |
|           33 |        6 | Timestamp   | 1373515812      |
|           34 |        6 | Reporter    | emergingthreads |
|           35 |        6 | botnet_id   | 0               |
|           36 |        6 | Source      | 129.79.49.81    |
+--------------+----------+-------------+-----------------+
36 rows in set (0.00 sec)```

# Advanced Events Plugin Configuration #

This section discusses the advanced features of Events for additional customization and fine tuning.

## Enabling Advanced Debug Messages ##

This section details how to enable additional debug messages for troubleshooting the Events plugin. This allows for more verbose output when troubleshooting database access for the Events plugin. **We highly recommend commenting out the following changes after the successful completion of the Advanced Events Plugin Configuration or after troubleshooting is no longer necessary.** Neglecting to do so will result in a very cluttered log file. After performing this step, the /var/log/nfsen/nfsen.log file will now include additional information such as:

  * SQL Query issued by the backend perl module to the MySQL database
  * Records returned by the MySQL query
  * UPDATE queries issued by the backend perl module to the MySQL database
  * DELETE queries issued by the backend perl module to the MySQL database

This information is necessary for testing and troubleshooting the database access in the backend of the Events plugin. Additionally, when we enable periodic queries in a subsequent section, this will allow us to view the UPDATE query being issued to the MySQL database in the logfile.

**Step 1:** Navigate to the backend plugins directory of NFSen and open Events.pm in a text editor

> ```
$ cd /usr/local/nfsen/plugins
$ vi Events.pm```

**Step 2:** Uncomment lines 626, 627, 648, 649

Change from

> ```
#_DEBUG($opts);
#_DEBUG($query);```

to

> ```
_DEBUG($opts);
_DEBUG($query);```

**Step 3:** Modify lines 631 and 653

Change from

> ```
while (my $line = $lines_query->fetchrow_hashref()) {```

to

> ```
while (my $line = $lines_query->fetchrow_hashref()) { _DEBUG($line);```

**Step 4: (Optional)** Modify lines 634 and 656

As indicated, this step is optional. Modifying these lines will display the records returned from the **attributes** MySQL table in /var/log/nfsen/nfsen.log.

Change from

> ```
while (my ($name, $value) = $attributes_query->fetchrow_array()) {```

to

> ```
 while (my ($name, $value) = $attributes_query->fetchrow_array()) { _DEBUG($line);```

**Step 5:** Enable debug messages for database deletions.

If not already present, add this line after line 353

> ```
_DEBUG("Delete query: ".$query);```

Lines 353-354 should now resemble the following:

> ```
my $query = "DELETE "._get_where_clause($opts);
_DEBUG("Delete query: ".$query);```

**Step 6:** Enable debug messages for database updates

Look for line 383

> ```
my $query = "INSERT INTO attributes (event_id, name, value) VALUES (?, ?, ?)";```

Add the following line immediately after 383

> ```
_DEBUG("Update query: ".$query);```

Lines 383-384 should now resemble the following:

> ```
my $query = "INSERT INTO attributes (event_id, name, value) VALUES (?, ?, ?)";
_DEBUG("Update query: ".$query);```

**Step 7:** Restart NFSen

> ```
$ sudo service nfsen stop
$ sudo service nfsen start```

If no syntax errors are present, parsing /var/log/nfsen/nfsen.log should yield the following:

> ```
$ grep Events /var/log/nfsen/nfsen.log | less```

Output:

> ```

Oct  5 16:23:03 ubuntu nfsen[2362]: Frontend module 'Events.php' found
Oct  5 16:23:03 ubuntu nfsen[2362]: Loading plugin 'Events': Success
Oct  5 16:23:03 ubuntu nfsen[2362]: Initializing plugin 'Events': Success```

> ```

Oct  5 16:23:03 ubuntu nfsen[2362]: Loading plugin 'Botnets': Success
Oct  5 16:23:03 ubuntu nfsen[2362]: Initializing plugin 'Botnets': Success```

### Verify Advanced Debug Messages Are Enabled ###

**Step 1:** Navigate to the Plugins Tab of the NFSen web GUI

**Example:**

![http://www.ren-isac.net/img/googlecode/7.2.1.1-Events_Plugin.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.1-Events_Plugin.jpg)

If the events database has already been populated with data, then the output could also resemble the following.

![http://www.ren-isac.net/img/googlecode/7.2-Known-Issues-1.jpg](http://www.ren-isac.net/img/googlecode/7.2-Known-Issues-1.jpg)

**Step 2:** Parse /var/log/nfsen/nfsen.log for the issued SQL query and returned records

> ```
$ grep Events /var/log/nfsen/nfsen.log | less```

**Example of expected output from events MySQL table:**

> ```

Oct  5 16:43:45 ubuntu nfsen[2706]: Cmd Decode: Events::get_event_count
Oct  5 16:43:45 ubuntu nfsen[2706]: Cmd Decode: Events::get_events_serialized
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: SELECT event_id, starttime, stoptime, updatetime, level, profile, type FROM events  ORDER BY starttime DESC LIMIT 10 OFFSET 0
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: profile, value: ./live
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: level, value: notify
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: updatetime, value: 1376945400
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: event_id, value: 10
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: stoptime, value: 1376945400
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: starttime, value: 1374602100
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: type, value: botnet
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: profile, value: ./live
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: level, value: notify
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: updatetime, value: 1376945400
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: event_id, value: 9
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: stoptime, value: 1376945400
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: starttime, value: 1374594900
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: type, value: botnet
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: profile, value: ./live
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: level, value: notify
Oct  5 16:43:45 ubuntu nfsen[2706]: Events: key: updatetime, value: 1376945400```

Additionally, if you use a tail command, the query results will be shown each time the plugins tab page is refreshed.

> ```
$ tail -f Events /var/log/nfsen/nfsen.log```

Verification of database updates and deletions are covered in [Customized Events Alert Levels](https://code.google.com/p/renisac/wiki/Botnet_Install#Customize_Events_Alert_Levels) and [Age Out Botnet Events](https://code.google.com/p/renisac/wiki/Botnet_Install#Age_Out_Botnet_Events).

## Events Plugin Query Syntax ##

```
Type:[eq]botnet Times:[ge]10 Level:[eq]Alarm```

## Customize Events Alert Levels ##

> ```
Oct  5 17:40:15 ubuntu nfsen[3960]: Events: Update query: INSERT INTO attributes (event_id, name, value) VALUES (?, ?, ?)```

## Age Out Botnet Events ##

# Known Issues #

This section is for any known issues or problems encountered. Feel free to comment about any errors/bugs/problems not covered in this section. If possible, indicate the following: version of NFSen, the problem that was experienced, conditions which caused the problem to happen, known cause of the problem, solutions found, and any additional information which helps describe the problem. Even if you encountered a problem and have not found a solution, please let us know. We will post any discovered issues in this section. Your comments and issues will help make this the most comprehensive NetFlow manual out there.

## Events: Stop Time Does Not Display After a Botnet Event Has Expired ##

**Status:** Resolved

**NFSen Version:** 1.3.6p1

**Plugin Name:** Events

**Plugin Version:** 0.3

#### Condition: ####

The events plugin is displaying incorrect output for the **stoptime** field of an event. Once an event is no longer observed, the stop time on the NFSen web front-end remains in the "active" state.

#### Cause: ####

Line 139 of /var/www/nfsen/plugin/Events.php contains a conditional statement which evaluates if the element _stoptime_ of array **$line** is set to a value or if it is NULL. If the variable is not set or is NULL then the string "active" is printed. Otherwise, display the UNIX timestamp in the format specified using the function [strftime](http://php.net/manual/en/function.strftime.php). The syntax mistake causes the boolean value of "False" to always be returned when isset evaluates the _stoptime_ element of array **$line**. The same is true even if the variable is set to a value other than NULL. This is causing the string "active" to be displayed even when a botnet event has been expired and assigned a UNIX timestamp. The solution to the problem can be found below.

#### Additional Information: ####

Every five minutes (by default), the botnet plugin evaluates whether an IP in the alert botlist filter is present. Under the %PluginConf tag and under the **periodic\_queries** parameter of **events**, the UpdateTime option indicates when an event is expired and considered no longer active. If the current time is 1200 seconds less than the last update time, the event is expired by assigning the current time to stoptime.

> ```

"UpdateTime"=>['[le]#$unix_time-1200#','#$unix_time#'],
"StopTime"=>["[null]",'#$unix_time#'],
```

Viewing the events table in the MySQL database reveals the event has expired and the stoptime column is assigned a UNIX timestamp.

**Example:**
> ```

mysql> select * from events;
+----------+------------+------------+------------+--------+---------+--------+
| event_id | starttime  | stoptime   | updatetime | level  | profile | type   |
+----------+------------+------------+------------+--------+---------+--------+
|        1 | 1373236800 | 1376945400 | 1376945400 | alarm  | ./live  | botnet |
|        2 | 1374592800 | 1376945400 | 1376945400 | alarm  | ./live  | botnet |
|        3 | 1374592800 | 1376945400 | 1376945400 | alarm  | ./live  | botnet |
|        4 | 1374592800 | 1376945400 | 1376945400 | alarm  | ./live  | botnet |
|        5 | 1374592800 | 1376945400 | 1376945400 | alarm  | ./live  | botnet |
|        6 | 1374592800 | 1376945400 | 1376945400 | notify | ./live  | botnet |
|        7 | 1374592800 | 1376945400 | 1376945400 | notify | ./live  | botnet |
|        8 | 1374594900 | 1376945400 | 1376945400 | notify | ./live  | botnet |
|        9 | 1374594900 | 1376945400 | 1376945400 | notify | ./live  | botnet |
|       10 | 1374602100 | 1376945400 | 1376945400 | notify | ./live  | botnet |
+----------+------------+------------+------------+--------+---------+--------+
10 rows in set (0.00 sec)

```

Although, the results from the sql query indicate an event has been expired, the web front-end displays the event as still being "active".

**Example:**

![http://www.ren-isac.net/img/googlecode/7.2-Known-Issues-1.jpg](http://www.ren-isac.net/img/googlecode/7.2-Known-Issues-1.jpg)

We enabled additional debug messages detailed in section [7.2.1.4 Advanced Events Plugin Configuration](https://code.google.com/p/renisac/wiki/Botnet_Install#Advanced_Events_Plugin_Configuration). Parsing /var/log/nfsen/nfsen.log for the results returned from the back-end perl module reveals the following:

> ```
$ grep Events /var/log/nfsen/nfsen.log | less```

> ```

Aug 19 16:55:57 ubuntu nfsen[2189]: Events: SELECT event_id, starttime, stoptime, updatetime, level, profile, type FROM events  ORDER BY starttime DESC LIMIT 10 OFFSET 0
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: profile, value: ./live
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: level, value: notify
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: updatetime, value: 1376945400
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: event_id, value: 10
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: stoptime, value: 1376945400
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: starttime, value: 1374602100
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: type, value: botnet
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: profile, value: ./live
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: level, value: notify
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: updatetime, value: 1376945400
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: event_id, value: 9
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: stoptime, value: 1376945400
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: starttime, value: 1374594900
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: type, value: botnet
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: profile, value: ./live
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: level, value: notify
Aug 19 16:55:57 ubuntu nfsen[2189]: Events: key: updatetime, value: 1376945400
```

With this information, we can conclude that the back-end perl module for the events plugin is correctly updating the MySQL events table. Additionally, the nfsen log file shows the SQL query being issued by the perl module as well as the results being returned. This indicates the value of stoptime is being retrieved and passed to the PHP front-end for the events plugin. Therefore, the problem is likely a front end issue. In line 139 of /var/www/nfsen/plugins/Events.php, the value of stoptime retrieved from the MySQL events table is printed to a table row in PHP. A conditional statement tests whether the element _stoptime_ of array **$line** is set to a value. If the variable is set, the UNIX timestamp is printed according to the format specified using the function [strftime](http://php.net/manual/en/function.strftime.php). Otherwise, a string of "active" is printed to indicate an in progress botnet event.

To establish whether the element _stoptime_ in the PHP code was set to the corresponding value in the DB, we utilized the variable dumping function **var\_dump** to dump the contents of the _stoptime_ element of array **$line**. The resulting value printed to the web front end was the correct UNIX timestamp retrieved from the stoptime column in the MySQL events table. Despite having a value, when you apply var\_dump to the conditional **isset** the returned value is always a boolean value of "False". The returned value should be "True" if the _stoptime_ element of array **$line** is set to a value. For example, **var\_dump**(isset($line->{"stoptime"}) always returns false. For testing purposes, we also tried other functions which are commonly used for testing the value of variables in PHP including **empty()**, and **is\_null()**. As expected, the boolean values returned were "True" and "True" indicating _stoptime_ had no value when it clearly did.

With this information, we concluded the problem is line 139 of Events.php. We discovered a syntax error in how the _stoptime_ element of array **$line** was being referenced. Although, the syntax mistake does not cause any PHP errors, it does cause the incorrect output to be displayed.

**/var/www/nfsen/plugins/Events.php Line 139**
> ```
<TD><?=isset($line->{"stoptime"})?strftime("%c",$line['stoptime']):"active"?>

Unknown end tag for &lt;/TD&gt;

```

#### Solution: ####

Apply the following patch:

**Step 1:** Open /var/www/nfsen/plugins/Events.php with a text editor

> ```
$ sudo vi /var/www/nfsen/plugins/Events.php```

**Step 2:** Apply the following patch

Navigate to line 139:

> ```
<TD><?=isset($line->{"stoptime"})?strftime("%c",$line['stoptime']):"active"?>

Unknown end tag for &lt;/TD&gt;

```

Replace with the following:

> ```
<TD><?=isset($line['stoptime'])?strftime("%c",$line['stoptime']):"active"?>

Unknown end tag for &lt;/TD&gt;

```

**Step 3:** Save and exit

After making this change, isset will now return "True" and will display the stoptime when stoptime is not NULL. Additionally, isset returns "False" when stoptime is NULL, which will result in an output string of "active". This indicates an in progress botnet event. The output will now resemble the following:

![http://www.ren-isac.net/img/googlecode/7.2.1.4-Events-All.jpg](http://www.ren-isac.net/img/googlecode/7.2.1.4-Events-All.jpg)